using SplineMesh;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

/// <summary>
/// This scripted started off as a copy of Example Growing Root and Rope Builder
/// in SplineMesh and has been modified to keep up with the mechanics of the Vine. 
/// And to not be overwritten by updates to SplineMesh.
/// 
/// Example of component to show the deformation of the mesh on a changing
/// interval and changing spline nodes.
/// 
/// In this example, as the MeshBender is working on spline space, it will update
/// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
/// it will compute the mesh only once on it's next update call.
/// 
/// This component is only for demo purpose and is not intended to be used as-is.
/// </summary>
[ExecuteInEditMode]
[RequireComponent(typeof(Spline))]
public class Vine : MonoBehaviour
{
    private bool _toUpdate = false;
    private GameObject firstSegment;
    private GameObject _generatedPhysicsGO;
    private GameObject GeneratedPhysicsGO
    {
        get
        {
            if (_generatedPhysicsGO == null)
            {
                string generatedName = "generated by " + GetType().Name;
                var generatedTranform = transform.Find(generatedName);
                _generatedPhysicsGO = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);
            }
            return _generatedPhysicsGO;
        }
    }

    float _splineToRigidBodyWeight = 0f; //Maybe interpolate between the spline position to the rigidbody?

    /// <summary>
    /// This is the child that the rendered mesh is in
    /// </summary>
    private GameObject generatedModelGameObject;
    private Spline spline;
    private float rate = 0;
    private MeshBender meshBender;
    internal List<GameObject> wayPoints = new List<GameObject>();

    [Header("Physics Settings")]
    public bool disablePhysics = true;

    public GameObject segmentPrefab;
    public int segmentCount;
    public float segmentSpacing;
    [Tooltip("Sending Rotations to the Spline can cause pinching in the mesh if you don't limit the rotation properly. Possible physics joint for that?")]
    public bool sendRotation = false;

    [Header("Visual Settings")]
    public Mesh mesh;
    public Material material;
    public Vector3 rotation;
    public Vector3 scale;

    public float startScale = 1;

    public float DurationInSecond;


	// Start is called before the first frame update
	void Start()
    {

    }

    private void OnEnable()
    {
        spline = GetComponent<Spline>();
        _toUpdate = true;
        rate = 0;
        Init();
    }

    private void OnValidate()
    {
        _toUpdate = true;
        Init();
    }

    // Update is called once per frame
    void Update()
    {
        rate += Time.deltaTime / DurationInSecond;
        if (rate < 1)
        {
            Contort();
            //rate--; //restart anim.
        }

        if (disablePhysics)
            return;

        if (_toUpdate)
        {
            _toUpdate = false;
            GeneratePhysicsGOs();
            UpdateSpline();
        }
        UpdateNodes();
    }

    /// <summary>
    /// This Changes the Spline to match the position of the rigidbodies.
    /// </summary>
    private void UpdateNodes()
    {
        int i = 0;
        foreach (GameObject wayPoint in wayPoints)
        {
            var node = spline.nodes[i++];
            if (Vector3.Distance(node.Position, transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f)
            {
                node.Position = transform.InverseTransformPoint(wayPoint.transform.position);
                if (sendRotation)
                    node.Up = wayPoint.transform.up;
            }
        }
    }

    /// <summary>
    /// Do we have to change the shape of the spline?
    /// </summary>
    private void UpdateSpline()
    {
        foreach (var point in wayPoints.ToList())
        {
            if (point == null) wayPoints.Remove(point);
        }

        int nodeCount = wayPoints.Count;
        // adjust the number of nodes in the spline.
        while (spline.nodes.Count < nodeCount)
        {
            spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
        }

        while (spline.nodes.Count > nodeCount && spline.nodes.Count > 2)
        {
            spline.RemoveNode(spline.nodes.Last());
        }
    }

    //came from spline asset
    private void Contort()
    {
        float nodeDistance = 0;
        int i = 0;
        foreach (var n in spline.nodes)
        {
            float nodeDistanceRate = nodeDistance / spline.Length;
            float nodeScale = startScale * (rate - nodeDistanceRate);
            n.Scale = new Vector2(nodeScale, nodeScale);
            if (i < spline.curves.Count)
            {
                nodeDistance += spline.curves[i++].Length;
            }
        }

        if (generatedModelGameObject != null)
        {
            meshBender.SetInterval(spline, 0, spline.Length * rate);
            meshBender.ComputeIfNeeded();
        }
    }

    private void Init()
    {
        //Block of code came from Spline asset
        string generatedName = "generated by " + GetType().Name;
        var generatedTranform = transform.Find(generatedName);
        generatedModelGameObject = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
            typeof(MeshFilter),
            typeof(MeshRenderer),
            typeof(MeshBender));

        generatedModelGameObject.GetComponent<MeshRenderer>().material = material;

        meshBender = generatedModelGameObject.GetComponent<MeshBender>();
        spline = GetComponent<Spline>();

        meshBender.Source = SourceMesh.Build(mesh)
            .Rotate(Quaternion.Euler(rotation))
            .Scale(scale);
        meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
        meshBender.SetInterval(spline, 0, 0.01f);
    }

    private void GeneratePhysicsGOs()
    {
        UOUtility.DestroyChildren(GeneratedPhysicsGO);
        wayPoints.Clear();

        float localSpacing = 0;
        Joint joint = null;
        for (int i = 0; i < segmentCount; i++)
        {
            GameObject seg = UOUtility.Instantiate(segmentPrefab, GeneratedPhysicsGO.transform);
            seg.transform.Translate(0, 0, localSpacing);

            Rigidbody segRB = seg.GetComponent<Rigidbody>();
            // we fix the first segment so that the vine won't fall
            if (i == 0)
            {
                firstSegment = seg;
                segRB.constraints = RigidbodyConstraints.FreezePosition;
                seg.GetComponent<Collider>().enabled = false; //disable the collider on the first/center of the plant.
            }
            else if (i == Mathf.Ceil(segmentCount/2))
			{
                //spawn object
                GameObject plantBlock = new GameObject("Generated Plant Block Collider")
                {
                    layer = 11
				};
				plantBlock.transform.position = seg.transform.position;
                plantBlock.transform.SetParent(seg.transform);
                SphereCollider plantBlockCollider = plantBlock.AddComponent<SphereCollider>();
                plantBlockCollider.radius = i * segmentSpacing;
            }

            // we attach the rigidbody to the joint of the previous segment
            if (joint != null)
            {
                joint.connectedBody = segRB;
            }
            joint = seg.GetComponent<Joint>();

            // we save segments as way points for the spline deformation.
            wayPoints.Add(seg);
            localSpacing += segmentSpacing;
        }
        UOUtility.Destroy(joint);
    }
}

//not working...
[CustomEditor(typeof(Vine))]
public class MyScriptEditor : Editor
{
    void OnInspectorGUI()
    {
        Vine vine = target as Vine;

        vine.disablePhysics = GUILayout.Toggle(vine.disablePhysics, "Flag");

        if (vine.disablePhysics)
		{
            //vine.segmentPrefab = EditorGUILayout.
            vine.segmentCount = EditorGUILayout.IntField(vine.segmentCount);
            vine.segmentSpacing = EditorGUILayout.FloatField(vine.segmentSpacing);
                //public GameObject segmentPrefab;
                //public int segmentCount;
                //public float segmentSpacing;
        }
            //vine.i = EditorGUILayout.IntSlider("I field:", vine.i, 1, 100);

    }
}